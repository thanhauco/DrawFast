import { z } from 'zod';

export const PointSchema = z.object({
  x: z.number().describe('The x-coordinate of the point.'),
  y: z.number().describe('The y-coordinate of the point.'),
});
export type Point = z.infer<typeof PointSchema>;

export const ShapeStyleSchema = z.object({
  strokeColor: z.string().regex(/^#(?:[0-9a-fA-F]{3}){1,2}$|^transparent$/, 'Invalid hex color or transparent').describe('The color of the stroke, e.g., "#RRGGBB" or "transparent".'),
  fillColor: z.string().regex(/^#(?:[0-9a-fA-F]{3}){1,2}$|^transparent$/, 'Invalid hex color or transparent').describe('The fill color of the shape, e.g., "#RRGGBB" or "transparent".'),
  strokeWidth: z.number().min(0).describe('The width of the stroke in pixels.'),
  fontSize: z.number().min(1).describe('The font size for text shapes, in pixels.'),
  fontFamily: z.string().describe('The font family for text shapes, e.g., "Arial, sans-serif".'),
});
export type ShapeStyle = z.infer<typeof ShapeStyleSchema>;

export const BaseShapeSchema = z.object({
  id: z.string().uuid().describe('A unique identifier for the shape (UUID).'),
  // type will be narrowed by specific shape schemas
  style: ShapeStyleSchema.describe('The styling properties for the shape.'),
  x: z.number().describe('The primary x-coordinate of the shape (e.g., top-left for rectangle, center for circle, start for text).'),
  y: z.number().describe('The primary y-coordinate of the shape (e.g., top-left for rectangle, center for circle, start for text).'),
  width: z.number().optional().describe('The width of the shape (for rectangle, or estimated for text).'),
  height: z.number().optional().describe('The height of the shape (for rectangle, or estimated for text).'),
  points: z.array(PointSchema).optional().describe('An array of points, used for lines and arrows. Typically [startPoint, endPoint].'),
  radius: z.number().optional().describe('The radius of the shape (for circles).'),
  text: z.string().optional().describe('The text content (for text shapes).'),
  selected: z.boolean().optional().describe('Whether the shape is currently selected.'),
  rotation: z.number().optional().describe('The rotation angle of the shape in degrees.'),
});

export const RectangleShapeSchema = BaseShapeSchema.extend({
  type: z.enum(['rectangle']).describe("The type of the shape, must be 'rectangle'."),
  width: z.number().min(0).describe('The width of the rectangle.'),
  height: z.number().min(0).describe('The height of the rectangle.'),
});
export type RectangleShape = z.infer<typeof RectangleShapeSchema>;

export const CircleShapeSchema = BaseShapeSchema.extend({
  type: z.enum(['circle']).describe("The type of the shape, must be 'circle'."),
  radius: z.number().min(0).describe('The radius of the circle.'),
});
export type CircleShape = z.infer<typeof CircleShapeSchema>;

export const LineShapeSchema = BaseShapeSchema.extend({
  type: z.enum(['line']).describe("The type of the shape, must be 'line'."),
  points: z.array(PointSchema).length(2).describe('An array of exactly two Points: [startPoint, endPoint]. The top-level x/y for this shape can be 0 or the coordinates of the first point.'),
});
export type LineShape = z.infer<typeof LineShapeSchema>;

export const ArrowShapeSchema = BaseShapeSchema.extend({
  type: z.enum(['arrow']).describe("The type of the shape, must be 'arrow'."),
  points: z.array(PointSchema).length(2).describe('An array of exactly two Points: [startPoint, endPoint]. The top-level x/y for this shape can be 0 or the coordinates of the first point.'),
});
export type ArrowShape = z.infer<typeof ArrowShapeSchema>;

export const TextShapeSchema = BaseShapeSchema.extend({
  type: z.enum(['text']).describe("The type of the shape, must be 'text'."),
  text: z.string().describe('The text content.'),
});
export type TextShape = z.infer<typeof TextShapeSchema>;

export const DrawingShapeSchema = z.union([
  RectangleShapeSchema,
  CircleShapeSchema,
  LineShapeSchema,
  ArrowShapeSchema,
  TextShapeSchema,
]).describe('A single drawable shape on the canvas. It can be a rectangle, circle, line, arrow, or text.');
export type DrawingShape = z.infer<typeof DrawingShapeSchema>;

// Schema for the AI flow input
export const AiPromptInputSchema = z.object({
  prompt: z.string().describe('The user\'s text prompt for generating content.'),
});
export type AiPromptInput = z.infer<typeof AiPromptInputSchema>;

// Schema for the AI flow output for diagrams
export const AiGeneratedShapesSchema = z.object({
  shapes: z.array(DrawingShapeSchema).describe('An array of shapes generated by the AI for a diagram.'),
});
export type AiGeneratedShapes = z.infer<typeof AiGeneratedShapesSchema>;


// --- Schemas for other AI generation types ---

// Board Item Schema (example, can be expanded)
export const BoardItemSchema = z.object({
    id: z.string().uuid().describe("Unique ID for the board item."),
    type: z.enum(['note', 'topic', 'action_item']).describe("Type of board item."),
    content: z.string().describe("Text content of the item."),
    x: z.number().describe("X position on the board (conceptual)."),
    y: z.number().describe("Y position on the board (conceptual)."),
    color: z.string().regex(/^#(?:[0-9a-fA-F]{3}){1,2}$|^transparent$/).optional().describe("Background color for the item (e.g. a sticky note).")
});
export type BoardItem = z.infer<typeof BoardItemSchema>;

export const AiGeneratedBoardSchema = z.object({
    title: z.string().optional().describe("Title for the generated board."),
    items: z.array(BoardItemSchema).describe("Array of items for the board (e.g., sticky notes, topics).")
});
export type AiGeneratedBoard = z.infer<typeof AiGeneratedBoardSchema>;


// Timeline Event Schema
export const TimelineEventSchema = z.object({
    id: z.string().uuid().describe("Unique ID for the timeline event."),
    title: z.string().describe("Title of the event."),
    date: z.string().describe("Date of the event (e.g., YYYY-MM-DD or descriptive like 'Q1 2024')."),
    description: z.string().optional().describe("Description of the event."),
    category: z.string().optional().describe("Category for visual grouping."),
});
export type TimelineEvent = z.infer<typeof TimelineEventSchema>;

export const AiGeneratedTimelineSchema = z.object({
    title: z.string().optional().describe("Title for the generated timeline."),
    events: z.array(TimelineEventSchema).describe("Array of events for the timeline.")
});
export type AiGeneratedTimeline = z.infer<typeof AiGeneratedTimelineSchema>;

// Project Plan Task Schema
export const ProjectPlanTaskSchema = z.object({
    id: z.string().uuid().describe("Unique ID for the task."),
    name: z.string().describe("Name of the task."),
    assignee: z.string().optional().describe("Person or team assigned to the task."),
    startDate: z.string().optional().describe("Start date (e.g., YYYY-MM-DD)."),
    endDate: z.string().optional().describe("End date (e.g., YYYY-MM-DD)."),
    status: z.enum(['todo', 'in_progress', 'completed', 'blocked']).optional().describe("Current status of the task."),
    dependencies: z.array(z.string().uuid()).optional().describe("Array of task IDs this task depends on."),
    description: z.string().optional().describe("Detailed description of the task.")
});
export type ProjectPlanTask = z.infer<typeof ProjectPlanTaskSchema>;

export const AiGeneratedProjectPlanSchema = z.object({
    projectName: z.string().optional().describe("Name of the project."),
    tasks: z.array(ProjectPlanTaskSchema).describe("Array of tasks for the project plan.")
});
export type AiGeneratedProjectPlan = z.infer<typeof AiGeneratedProjectPlanSchema>;
